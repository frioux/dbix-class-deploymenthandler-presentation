<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>DBIx::Class::DeploymentHandler (aka DBICDH)</title>
<!-- metadata -->
<meta name="contributor" content="youcan[64]netzgesta[46]de" />
<meta name="publisher" content="s5.netzgesta.de" />
<meta name="description" content="S5 1.3 is a very flexible and lightweight slide show system available for anyone to use (including transitions and scalable fonts and images)" />
<meta name="keywords" content="S5, version 1.3, slide show, presentation-mode, projection-mode, powerpoint-like, scala-like, keynote-like, incremental display, scalable fonts, scalable images, transitions, notes, osf, xoxo, css, javascript, xhtml, public domain" />

<meta name="generator" content="S5" />
<meta name="version" content="1" />
<meta name="subject" content="DBIx::Class::DeploymentHandler" />
<meta name="author" content="See first slide" />
<meta name="company" content="N/A" />
<meta name="robots" content="index, follow" />
<meta name="revisit-after" content="7 days" />
<!-- meta additionally -->
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta http-equiv="Content-Script-Type" content="text/javascript" />
<meta http-equiv="Content-Style-Type" content="text/css" /><!-- configuration parameters -->
<meta name="defaultView" content="slideshow" />
<meta name="controlVis" content="hidden" />
<!-- configuration transition extension -->
<meta name="tranSitions" content="true" />
<meta name="fadeDuration" content="500" />
<meta name="incrDuration" content="250" />
<!-- configuration autoplay extension -->
<meta name="autoMatic" content="false" />
<meta name="playLoop" content="true" />
<meta name="playDelay" content="10" />
<!-- configuration audio extension -->
<meta name="audioSupport" content="false" />
<meta name="audioVolume" content="0" />
<meta name="audioError" content="false" />
<!-- configuration audio debug -->
<meta name="audioDebug" content="false" />
<!-- style sheet links -->
<link rel="stylesheet" href="ui/scala_utf/slides.css" type="text/css" media="projection" id="slideProj" />
<link rel="stylesheet" href="ui/scala_utf/outline.css" type="text/css" media="screen" id="outlineStyle" />
<link rel="stylesheet" href="ui/scala_utf/print.css" type="text/css" media="print" id="slidePrint" />
<link rel="stylesheet" href="ui/scala_utf/opera.css" type="text/css" media="projection" id="operaFix" />
<!-- embedded styles -->
<style type="text/css" media="all">
.imgcon {width: 100%; margin: 0 auto; padding: 0; text-align: center;}
#anim {width: 33%; height: 320px; position: relative;}
#anim img {position: absolute; top: 0px; left: 0px;}
.red {color: red;}
.grey {color: gray;}
</style>
<!-- S5 JS -->
<script src="ui/scala_utf/slides.js" type="text/javascript"></script>
</head>
<body>

<div class="layout">
   <div id="controls"><!-- DO NOT EDIT --></div>
   <div id="currentSlide"><!-- DO NOT EDIT --></div>
   <div id="header"></div>
   <div id="footer">
      <h1>DBIx::Class::DeploymentHandler</h1>
      <h2>YAPC::NA 2010</h2>
   </div>
</div>

<div class="presentation">

   <div class="slide">
      <h1>DBIX::Class::DeploymentHandler (aka DBICDH)</h1>
      <h4>Arthur Axel "fRIOUX" Schmidt</h4>
   </div>

   <div class="slide">
      <h1>What is DBICDH?</h1>
      <p>DBIx::Class::DeploymentHandler - DBIx::Class::Schema
      deployment for multiple versions.</p>
      <div class="notes">
         <ul>
            <li>w/o multiple versions -&gt;deploy is certainly easier</li>
         </ul>
      </div>
   </div>

   <div class="slide">
      <h1>Why not just use DBIx::Class::Schema::Versioned?</h1>
      <ul class="incremental">
         <li>Not a component on Schema &there4; DBIx::Class::Journal</li>
         <li>Much more extensible</li>
         <li>A clean break from backcompat</li>
      </ul>
   </div>

   <div class="slide">
   <h1>YUCK.</h1>
<pre style="font-size:35%;">sub _set_db_version {
  my $self = shift;
  my ($params) = @_;
  $params ||= {};

  my $version = $params-&gt;{version} ? $params-&gt;{version} : $self-&gt;schema_version;
  my $vtable = $self-&gt;{vschema}-&gt;resultset('Table');

  ##############################################################################
  #                             !!! NOTE !!!
  ##############################################################################
  #
  # The travesty below replaces the old nice timestamp format of %Y-%m-%d %H:%M:%S
  # This is necessary since there are legitimate cases when upgrades can happen
  # back to back within the same second. This breaks things since we relay on the
  # ability to sort by the 'installed' value. The logical choice of an autoinc
  # is not possible, as it will break multiple legacy installations. Also it is
  # not possible to format the string sanely, as the column is a varchar(20).
  # The 'v' character is added to the front of the string, so that any version
  # formatted by this new function will sort _after_ any existing 200... strings.
  my @tm = gettimeofday();
  my @dt = gmtime ($tm[0]);
  my $o = $vtable-&gt;create({
    version =&gt; $version,
    installed =&gt; sprintf("v%04d%02d%02d_%02d%02d%02d.%03.0f",
      $dt[5] + 1900,
      $dt[4] + 1,
      $dt[3],
      $dt[2],
      $dt[1],
      $dt[0],
      $tm[1] / 1000, # convert to millisecs, format as up/down rounded int above
    ),
  });
}</pre>
   </div>

   <div class="slide">
      <h1>Introduction to the defaults</h1>
      <ul class="incremental">
         <li>lots of options</li>
         <li>defaults/recommended</li>
      </ul>
      <div class="notes">
         <p>There are already a lot of different options for building your own
         DBICDH, we'll talk about the defaults (aka recommended) here.</p>
      </div>
   </div>

   <div class="slide">
      <h1>Monotonic Version Handler</h1>
      <ul class="incremental">
         <li>integers only</li>
         <li>easily move from one version to the next</li>
      </ul>
      <div class="notes">
         <p>The monotonic version handler uses integer only versions, which
         follow naturally per revision or release or whatever.  So you first
         version would be 1, the second would be 2, etc.</p>
         <p>The main benefit of monotonic is that it is perfectly simple
         and predictable.  No issues of how versions are parsed or ordered
         or any of that.</p>
      </div>
   </div>

   <div class="slide">
      <h1>SQL::Translator Deploy Method</h1>
      <ul class="incremental">
         <li>SQLT for SQL generation</li>
         <li>Runs upgrade scripts</li>
      </ul>
      <div class="notes">
         <p>The SQLT deploy method uses SQLT to generate SQL for installs,
         upgrades, and downgrades.  In addition to that it does the actual
         running of SQL and Perl scripts and defines the directory layout
         for the scripts.</p>
      </div>
   </div>

   <div class="slide">
      <h1>SQLTDM - Perl Scripts</h1>
      <ul class="incremental">
         <li>similar to .psgi - anonymous coderef</li>
         <li>First arg is the schema (except for preinstall)</li>
      </ul>
      <div class="notes">
         <p>A Perl script used by SQLTDM is actually very similar to a .psgi
         script.  It should just be an anonymous subref.  Scripts for install,
         upgrade, and downgrade get the schema as their first argument.
         The preinstall scripts are not passed any arguments.</p>
      </div>
   </div>

   <div class="slide">
      <h1>SQLTDM - Serialized SQL</h1>
      <ul class="incremental">
         <li>JSON serialized array of SQL statements</li>
         <li>Blame SQLT</li>
      </ul>
   </div>

   <div class="slide">
      <h1>SQLTDM - Directory Layout</h1>
      <p>Note: this is heavily based upon DBIx::Migration::Directories</p>
<pre style="font-size:45%;">$sql_migration_dir
 |- SQLite
 |  |- down
 |  |  `- 2-1
 |  |     `- 001-auto.sql-json
 |  |- schema
 |  |  `- 1
 |  |     `- 001-auto.sql-json
 |  `- up
 |     |- 1-2
 |     |  `- 001-auto.sql-json
 |     `- 2-3
 |        `- 001-auto.sql-json
 |- _common
 |  |- down
 |  |  `- 2-1
 |  |     `- 002-remove-customers.pl
 |  `- up
 |     `- 1-2
 |        `- 002-generate-customers.pl
 `- MySQL
    |- down
    |  `- 2-1
    |     `- 001-auto.sql-json
    |- preinstall
    |  `- 1
    |     |- 001-create_database.pl
    |     `- 002-create_users_and_permissions.pl
    |- schema
    |  `- 1
    |     `- 001-auto.sql-json
    `- up
       `- 1-2
          `- 001-auto.sql-json</pre>
   </div>

   <div class="slide">
      <h1>Standard Version Storage</h1>
      <ul class="incremental">
         <li>autoinc instead of monster date</li>
      </ul>
      <div class="notes">
         <p>Not a whole lot worth saying here.  The main change from
         ::Versioned is that instead of that crazy date thing I pointed out
         above it uses a simple autoincrementing id.</p>
      </div>
   </div>

   <div class="slide">
      <h1>General Usage</h1>
   </div>

   <div class="slide">
      <h1>preinstall</h1>
      <ul class="incremental">
         <li>Optional, but recommended by the frewmbot</li>
         <li>CREATE DATABASE</li>
         <li>only Perl</li>
      </ul>
      <div class="notes">
         <p>The preinstall stage, while not required, should vastly reduce the
         amount of manual intervention required for a deploy.  Typical usage
         will probably be something like having it do CREATE DATABASE FOO
         as well as adding a few users to the database and whatnot.</p>
         <p>Because preinstall is such an open-ended stage, it currently
         only supports running perl scripts, instead of perl and sql like
         the rest of the stages.</p>
      </div>
   </div>

   <div class="slide">
      <h1>preinstall example</h1>
<pre># $migrations/MySQL/preinstall/1/001_create_database.pl
sub {
   use DBI;
   my $user     = 'root'; # you should probably
   my $password = 'foo';  # prompt the user for
   my $dsn      = 'bar';  # at least the password
   my $dbh      = DBI-&gt;connect($dsn, $user, $password);
   $dbh-&gt;do('CREATE DATABASE frewmbot') or die 'Shucks howdy!  FAIL:' . $@;
};
</pre>
   </div>

   <div class="slide">
      <h1>install</h1>
      <ul class="incremental">
         <li>run prepare_install first</li>
         <li>schema deploy</li>
         <li>version storage install</li>
         <li>Other basic population</li>
      </ul>
      <div class="notes">
         <p>The install stage is where the schema gets deployed, as well as
         your version storage.  In general this will be mostly automatic,
         unless you want to do something like prepopulate a users table.</p>
      </div>
   </div>

   <div class="slide">
      <h1>install example</h1>
<pre># $migrations/_common/install/1/001_create_users.pl
sub {
   my $schema = shift;
   my @useless = $schema-&gt;resultset('User')-&gt;populate([
      {username =&gt; 'frew', password =&gt; 'test' },
   ]);
};
</pre>
   </div>

   <div class="slide">
      <h1>upgrade</h1>
      <ul class="incremental">
         <li>run prepare_install + prepare_upgrade first</li>
         <li>schema modifications</li>
         <li>vanilla additions/deletions should be automatic</li>
         <li>column renames need user scripting</li>
         <li>also: downgrade</li>
      </ul>
      <div class="notes">
         <p>This stage is where your schema gets modified.  If you are doing
         simple changes like adding/removing tables/columns it should be
         entirely automatic.  If you are renaming things or transforming
         data you'll need to add some scripts yourself.</p>
      </div>
   </div>

   <div class="slide">
      <h1>upgrade example</h1>
<pre># $migrations/_common/upgrade/1-2/001_hash_passwords.pl
sub {
   my $schema = shift;
   $_-&gt;update({ password =&gt; $_-&gt;get_column('password') })
      for $schema-&gt;resultset('User')-&gt;all;
};
</pre>
   </div>

   <div class="slide">
      <h1>Quick rant about implementation</h1>
      <p>Parameterized Roles &#8867; MI like Delegation</p>
      <p>Should probably use something more proven at some point, but right
      now my half baked solution works great.</p>
   </div>

   <div class="slide">
      <h1>Customization</h1>
   </div>

   <div class="slide">
      <h1>VersionHandler</h1>
      <p>Git style non-linear upgrades</p>
   </div>

   <div class="slide">
      <h1>VersionStorage</h1>
      <p>Changing table name</p>
   </div>

   <div class="slide">
      <h1>DeployMethod</h1>
      <p>?</p>

   <div class="slide">
      <h1>Questions?</h1>
      <ul class="incremental">
         <li>Is fREW single?</li>
         <li>How many licks does it take to get to the center of a lolly pop?</li>
         <li>When will Perl 6 be released?</li>
      </ul>
   </div>

   <div class="slide">
      <h1>THE END</h1>
   </div>

</div>
</body>
</html>
